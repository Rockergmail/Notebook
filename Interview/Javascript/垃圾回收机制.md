<!--
 * @description: 
 * @author: xiangrong.liu
 * @Date: 2021-06-04 10:17:59
 * @LastEditors: xiangrong.liu
 * @LastEditTime: 2021-06-04 16:09:48
-->
v8垃圾回收机制：分代式垃圾回收机制

### 为什么需要垃圾回收
1. 当执行一个函数的时候，会把函数推进当前的执行栈，其中会记录当前作用域分配的变量，当执行完函数，会释放掉变量，清除掉作用域使用的内存空间。
2. 如果其中的变量有被引用，则不会清除，会一直占用着内存，如果大量的占用没被回收的变量，会导致内存溢出，导致程序崩溃或者被利用攻击。

V8内存结构：
代码区：唯一可运行的内存区域
新生区
老生区
大对象区
map区

新生区：内存分配32M（64位系统是分配32M，32位系统是分配16M），把内存分为两份，每份都成为半空间（semi-space），处于激活状态的半空间称为From空间，处于非激活状态的半空间称为To空间。新生区的算法是利用空间换时间。
1. 声明的对象，会分配到From空间。程序执行完，检查From空间存活的对象，把存活的对象复制到To空间，然后把From空间的非存活的对象清除掉。
2. 把From区和To区调换。重复步骤1，如果当前存活的对象是经过Scavenge算法还存在，或者To空间占内存用25%，则会晋升老生区

老生区：
1. 引用计数法。变量仍在被引用，则标记为活动的对象，不进行回收。缺点：当一个函数里面的两个对象循环引用，但是函数已经不会再被调用，这个时候不会回收掉，导致内存泄露。所以放弃此方案。
2. 标记清除法。从根对象（可以是全局对象，可以是某个上下文，以及引用的作用域链的一个节点）是否能访问到对应的变量，如果能则表示活动的对象，不能则表示不能活动的变量。优点：可以清除上述循环引用的情况。缺点：因为对象是连续分布的，清除会导致内存碎片，无法充分利用内存。
3. 标记整理法。把活动的对象挪到内存的另一侧，把没有活动的对象清除掉。优点：解决内存碎片的问题。缺点：js是单线程运行的，当执行垃圾回收整理时，会导致js的同步代码堵塞，当活动的对象很多，响应整理的耗时也会变长。
4. 增量标记、延迟清理、增量整理。减少垃圾回收时导致的应用卡顿。
5. 并行标记、并行整理：利用多核CPU的性能，提高垃圾回收的效率。

### 如何避免内存泄露
1. 尽量避免使用全局变量
2. DOM引用及时清除
3. 清除没有用到的计时器
4. 尽量避免使用闭包
5. 弱引用？


### 涉及到其他的知识

### Reference
https://juejin.cn/post/6844904016325902344