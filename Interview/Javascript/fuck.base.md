执行栈/执行上下文，变量提升，函数优先赋值
变量，作用域，作用域链，with、eval、闭包，变量的生命周期，垃圾回收机制
this，原型，原型链，实现new
eventloop/settimeout/setimmedite/callback/promise/generator/asyn
use strict

dom
xhr/websocket/http/cookie/
渲染线程
storage:cookie/localstorage/sessionstorage/
资源加载

js单线程，如何多线程？web worker/ service worker

js引擎，编译器编译代码成为可执行代码，然后执行代码。

编译过程，对变量声明提升，函数优先赋值。变量存放在作用域上，作用域管理着变量的生命周期，当变量没有被引用，就会被回收。作用域有很多种：全局作用域、函数作用域、块作用域。当执行函数时，会推入执行栈，函数嵌套执行另外一个函数，就有作用域嵌套。这时候就产生了函数执行上下文，执行上下文对象包括：this绑定的对象、变量、函数、上层作用域的引用。执行上下文有三种：全局、函数、eval。一般来说，当查询变量时，先从代码执行当前的作用域去查询，如果没有就往上一级执行栈的作用域去查找，如果有就返回对应的值，如果没有就一直查到全局作用域，如果都没有则返回未声明该变量。这个也有例外，就是闭包，闭包的形式是函数返回了新函数，而且新函数引用了函数的变量。这导致函数以及里面的变量没有被回收。闭包可以让函数在词法作用域之外调用，而且还可以访问它的词法作用域。this是运行时绑定的，指向被调用的对象。闭包的应用：模块化、异步。this有5种绑定方法：new方法绑定、明确绑定如apply/call/bind方法、隐含绑定，调用点是一个对象，譬如一个对象的属性是一个方法，方法的this就是指向这个对象的、默认绑定，在全局调用，指向全局对象、词法this，它指向对象的声明方法有很多，如词法声明、Object.create、以及通过new一个构造函数得到一个对象。js是通过prototype来实现面向对象的，一个构造函数有一个构造函数对象，它的实例的__proto__指向构造函数的prototype，而它本来也是一个对象实例，所以它的__proto__指向Object.prototype，而Object.prototype.__proto__是null，这就是原型链。当实现继承的功能，需要继承父的方法和属性，继承属性，调用父构造函数Father.call(this)，；继承方法，只需要new Father()得到一个实例，而且这个实例的construct指向子构造函数。


复制，深度复制object，要考虑的点