<!--
 * @description: 
 * @author: xiangrong.liu
 * @Date: 2021-06-01 15:12:40
 * @LastEditors: xiangrong.liu
 * @LastEditTime: 2021-06-03 11:57:37
-->

浏览器的组成

### 从收到 HTML、CSS 和 JavaScript 字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤，优化性能其实就是了解这些步骤中发生了什么 - 即关键渲染路径。

浏览器加载html之后，进行解析：字节--文本--tokens--nodes--DOM，当构建完DOM之后会执行domcontentloaded事件
扫描css、js等资源
下载css资源，阻塞渲染，阻塞js执行。下载完之后进行解析：字节--文本--token--node--CSSOM，构建完CSSOM，js脚本才可以执行
下载js资源，阻塞html解析，阻塞渲染，下载完马上执行，js执行原理--这里先忽略
DOM和CSSOM结合成渲染树，根据渲染树进行布局（layout）：计算每个节点的几个信息：大小、位置、分配到哪个图层等；合并图层；进行绘制（paint、栅格化）：上颜色
如果js改变了DOM或者CSSOM，会重新执行构建DOM、构建CSSOM、构建渲染树，进行回流、重排
浏览器有默认的样式，所以有现成的CSSOM，所以就算没有认为的引入CSS，也会进行渲染


### 优化关键渲染路径就是指了解和优化 HTML、CSS 和 JavaScript 之间的依赖关系谱并最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。

html资源：
特性：HTML 被视为阻塞渲染的资源，因为渲染需要DOM
策略：别让js脚本阻止dom解析

css资源：
特性：
1. CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。
2. CSSOM构建完之前，JS是不能执行的
策略：
减少关键css数量：
1. 合并css
2. 通过媒体类型和媒体查询将一些 CSS 资源标记为不阻塞渲染（浏览器会下载所有 CSS 资源，无论阻塞还是不阻塞）
减少关键css大小：
1. 精简CSS
2. 压缩css
缩短关键css路径：
1. 将 CSS 置于文档 head 标签内，以便浏览器尽早发现 <link> 标记并尽早发出 CSS 请求
2. 避免使用 CSS import，因为它们会在关键路径中增加往返次数
3. 内联阻塞渲染的 CSS
   
js资源：
特性：
1. JavaScript 可以查询和修改 DOM 与 CSSOM。
2. 当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。执行我们的内联脚本会阻止 DOM 构建，也就延缓了首次渲染。
3. 如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，会怎样？答案很简单，对性能不利: 浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。
4. 由于网页上还有一个阻止 JavaScript 文件的解析器，系统会在下载并解析 CSS 文件之前阻止 domContentLoaded 事件: 因为 JavaScript 可能会查询 CSSOM，我们必须在下载 CSS 文件之前将其阻止，然后才能执行 JavaScript
5. script，下载页会block html parse。script async，下载是并行的，执行才会block HTML parse。script defer，下载是并行的，等待html parse完才执行
策略：
1. 向 script 标记添加async关键字可以指示浏览器在等待脚本可用期间不阻止 DOM 构建，这样可以显著提升性能。
2. 将javascript放在body底部（两者结合）

作为每个可靠性能策略的基础，准确的评估和检测必不可少。 无法评估就谈不上优化。

优化关键渲染路径能够让浏览器尽可能快地绘制网页: 更快的网页渲染速度可以提高吸引力、增加网页浏览量以及提高转化率。为了最大程度减少访客看到空白屏幕的时间，我们需要优化加载的资源及其加载顺序。


到目前为止，我们只关注了资源（CSS、JS 或 HTML 文件）可供处理后浏览器中会发生的情况，而忽略了从缓存或从网络获取资源所需的时间。

还需要考虑图片资源、字体资源

让我们定义一下用来描述关键渲染路径的词汇:

**关键资源: ** 可能阻止网页首次渲染的资源。
**关键路径长度: ** 获取所有关键资源所需的往返次数或总时间。
**关键字节: ** 实现网页首次渲染所需的总字节数，它是所有关键资源传送文件大小的总和。我们包含单个 HTML 页面的第一个示例包含一项关键资源（HTML 文档）；关键路径长度也与 1 次网络往返相等（假设文件较小），而总关键字节数正好是 HTML 文档本身的传送大小。

为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素:

关键资源的数量。
关键路径长度。
关键字节的数量。

**优化关键渲染路径的常规步骤如下: **

对关键路径进行分析和特性描述: 资源数、字节数、长度。
最大限度减少关键资源的数量: 删除它们，延迟它们的下载，将它们标记为异步等。
优化关键字节数以缩短下载时间（往返次数）。
优化其余关键资源的加载顺序: 您需要尽早下载所有关键资产，以缩短关键路径长度。


https://developers.google.com/web/fundamentals/performance/critical-rendering-path?hl=zh-cn

什么因素影响了首次渲染的速度？
1. 渲染的机制是如何实现的？dom+cssom=render tree + layout + paint
2. 不同的关键渲染资源，对渲染有什么影响？html parse、css parse、js exec各有什么影响
2. 因素如下：关键渲染路径涉及到的资源，数量、请求往返次数、数据大小、资源加载和执行对渲染的影响以及它们之间的依赖关系是如何的？

最佳实践：
1. script放到底部，加上async、defer也可以，注意区别
2. css放在head里，尽早让浏览器去加载css。避免使用@import。可以考虑内联css。可以考虑用媒体查询来实现非阻塞渲染。

什么场景：
1. 优化、最佳实践（工程化，脚手架）

这个知识点，往前可以牵扯到：
1. 从domain到下载过程，其中如何优化的问题。
2. 再次渲染的问题，如何降低耗能，提高效率？什么会影响降低的

http缓存的优化
获取位置信息，就会强制重排
css3产生图层
脱离文档流

defered有顺序，async无顺序，下载完就直接执行，最好不要操作dom

css是如何解析的：先匹配子，再匹配父，减少通配符。css contain。

intersectionobserver

raf