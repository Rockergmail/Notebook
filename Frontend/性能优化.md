
osi七层
应用层 http
表示层
会话层 ssl

传输层 tcp安全可靠，可分段发送数据，有序 udp丢包重发
网络层 ip

数据链路层
物理层



从url到加载完毕，有哪些环节，哪些环节是可以做优化的。


浏览器输入url，如果有缓存，缓存在有效期内，就读缓存的文件。
如果没有，进行dns解析得到ip
如果是https进行ssl协商
通过ip进行寻址，进入请求队列，排队等待，最多并发数是6个。
tcp创建连接，进行tcp三次握手
http发送请求，包括请求行、请求头、请求体。默认不会断开连接，因为http1.1有keep-alive属性，可以复用上次的连接。
服务器收到请求，返回状态码、响应行、响应头、响应体。301\302会重定向，301是永久重定向，302是临时重定向，对seo来说，301要改地址。304告诉客户端资源没有改动，直接读缓存并更新缓存时间。会返回对应的静态html文件，如果是ssr则进入对应的controller，请求数据库得到数据，然后渲染模板，生成html。返回浏览器。
浏览器收到相应，解析html成dom，当遇到link标签，异步加载并解析css，当遇到script标签，同步加载并解析js。cssom和dom结合，行程渲染树，渲染树进行layout、paint，渲染到页面上。

请求：
1. 利用缓存，减少不必要的请求
2. dns预解析
3. 升级为http2，充分发挥链路服用，减少频繁的三次握手导致的延误
4. 减少请求数：合并js、css
5. 申请多个域名，突破同个域名并发6个请求的限制
6. 压缩资源，减轻payload大小，gzip
7. CDN
8. 图片资源：可以用webp、svg，iconfont、雪碧图，对不同
9. preload预加载当前页面的资源，prefetch预加载未来页面的资源

渲染：
1. script标签放到body底部，如果是在头部，尽量用defered，注意deffered和async的区别，前者是异步加载，dom加载完再执行；后者是异步加载，加载完同步执行
2. 不要频繁dom操作，尽量用vdom，或者操作存在一起
3. 尽量css动画，开启3d，在独立的渲染层渲染

如何检测性能？并上报。如果建立标准，如何优化。