### 作用域的工作模型

1. 词法作用域
1. 动态作用域 

这里主要讨论词法作用域，JavaScript 实际上没有动态作用域

### 词法作用域

简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。

### 词法作用域特点

1. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由 函数被声明时所处的位置决定。注意区分this。

1. 词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。

### 欺骗词法作用域

**eval**

在执行eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。（在运行时）

```js
function foo(str, a) {
    eval(str), console.log(a, b)
}
var b = 2;
foo("var b = 3;", 1);
```

---

在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

```js
function foo(str) {
    "use strict";
    eval(str), console.log(a) 
    // ReferenceError: a is not defined
}
foo("var a = 2");
```

---

**with**

通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（在运行时）。

```js
function foo(obj) {

    with (obj) {
    	a = 2
    }
}
var o1 = {
  	  a: 3
	}, 
	o2 = {
        b: 3
    };

foo(o1)
console.log(o1.a)  // 2
foo(o2)
console.log(o2.a)  // undefined
console.log(a);  // 2   //不成功的LHS引用会导致自动隐式地创建一个全局变量

```

---

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为无法在词法分析阶段明确知道eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给with 用来创建新词法作用域的对象的内容到底是什么。导致代码运行变慢。

不要使用它们。

### 动态作用域

词法作用域
```js
function foo() {
    console.log( a ); // 2
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;

bar(); // 2
```

动态作用域
```js
function foo() {
    console.log( a ); // 3  (不是 2!)
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;

bar();
```

词法作用域 vs 动态作用域 vs this：

词法作用域是在代码编写时静态地定义的（除了eval()或with）
动态作用域（和this）是在代码运行时被确定的

词法作用域关心的是函数在何处被声明(函数和作用域是在哪里和如何被声明的)
动态作用域关心的是函数从何处被调用(作用域链条是基于调用栈的，而不是代码中作用域的嵌套)
this关心的是函数是如何被调用的

### 疑问

> 词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

什么叫做“有状态的解析过程”？

### 参考资料
《You Don't Know Js》（主要参考）