作用域共有两种主要的工作模型：
1. 词法作用域
1. 动态作用域 

这里主要讨论词法作用域

---

### 词法作用域

简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。

### 词法作用域特点

1. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由 函数被声明时所处的位置决定。注意区分this。

1. 词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。

### 欺骗词法作用域

**eval**

在执行eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。（在运行时）

```js
function foo(str, a) {
    eval(str), console.log(a, b)
}
var b = 2;
foo("var b = 3;", 1);
```

---

在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

```js
function foo(str) {
    "use strict";
    eval(str), console.log(a) 
    // ReferenceError: a is not defined
}
foo("var a = 2");
```

---

**with**

通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（在运行时）。

```js
function foo(obj) {

    with (obj) {
    	a = 2
    }
}
var o1 = {
  	  a: 3
	}, 
	o2 = {
        b: 3
    };

foo(o1)
console.log(o1.a)  // 2
foo(o2)
console.log(o2.a)  // undefined
console.log(a);  // 2   //不成功的LHS引用会导致自动隐式地创建一个全局变量

```

---

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为无法在词法分析阶段明确知道eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给with 用来创建新词法作用域的对象的内容到底是什么。导致代码运行变慢。

不要使用它们。

### 疑问

> 词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

什么叫做“有状态的解析过程”？

### 参考资料
《You Don't Know Js》（主要参考）