作用域共有两种主要的工作模型：
1. 词法作用域
1. 动态作用域 

这里主要讨论词法作用域

---

### 词法作用域

无论标识符声明出现在作用域中的何处 ，这个标识符所代表的变量或函数都将附属于所处作用域


函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript变量可以根据需要改变值类型的“动态”特性。


实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。

最小特权原则

软件设计

比如某个模块或对象的API设计。

规避冲突

“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。


必须声明一个具名函数foo() ，意味着foo 这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。其次，必须显式地通过函数名（foo() ）调用这个函数才能运行其中的代码。


如果function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式


函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。


比较一下前面两个代码片段。第一个片段中foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中foo 被绑定在函数表达式自身的函数中而不是所在作用域中。

换句话说，(function foo(){ .. }) 作为函数表达式意味着foo 只能在.. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。


函数表达式可以是匿名的，而函数声明则不可以省略函数名——在JavaScript的语法中这是非法的。


匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。

2. 如果没有函数名，当函数需要引用自身时只能使用已经过期 的arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。

3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。


---

第一个( ) 将函数变成表达式，第二个( ) 执行了这个函数。

函数名对IIFE当然不是必须的，IIFE最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的IIFE并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。

（Immediately Invoked Function Expression）；

ss

### 疑问

> 词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

什么叫做“有状态的解析过程”？

### 参考资料
《You Don't Know Js》（主要参考）