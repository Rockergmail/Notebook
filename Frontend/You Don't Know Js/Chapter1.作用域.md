
### 自己之前的理解
1. 作用域，就是变量有效的范围
1. 作用域可以嵌套，形成作用域链。当变量在里层的作用域找不到，会往上一级的作用找，直到最外层的作用域（global/window）无论找到或者找不到都会停止继续查找

### 作用域存在的意义

当程序需要获取变量的值，或者为变量赋值，程序如何找到这个变量？作用域就是程序找到这个变量的规则。

它负责收集并维护由所有声明的变量组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些变量的访问权限。


### js引擎的工作流程

JavaScript归类为“动态”或“解释执行”语言，事实上它是一门编译语言，编译完马上执行

**js引擎的工作流程：**

编译 [词法分析（Tokenizing）-> 语法分析（Parsing） -> 代码生成] -> 执行

**词法分析：**

把源代码分解成词法单元（token）
```var a = 2;``` 分解为 ```var```、```a```、```=```、```2```、```;```

**语法分析：**

把词法单元数组转换成“抽象语法树”（Abstract Syntax Tree，AST）

**代码生成：**

将AST转化成一组机器指令，创建变量（包括分配内存），存值等操作

### 作用域的工作流程

当编译器生成代码，执行赋值时，会为变量进行LHS查询或RHS查询。
RHS查询就是查找某个变量的值；LHS查询是试图找到变量的容器本身（内存地址）


```javascript
function foo (a) {

	console.log(a)
}

foo(2)
```

1. 编译阶段。//FIXME: 函数的编译阶段需要了解
1. 执行阶段，在全局作用域RHS查询foo，知道是一个函数，就进入函数并执行，进入子作用域；
1. 为形参a赋值，对a做LHS查询，然后把2赋值给a；
1. 对console作RHS查询，知道是一个内置对象，然后查找一下有没有log，知道log是一个函数，就执行
1. 对a做RHS，把a的值（2）传进log函数并执行

---

```javascript
function foo (a) {

	console.log(a + b)
}

var b = 2;

foo(2)
```

1. 编译阶段，遇到var b，检查本作用域是否已经一个变量叫做b，有则忽略该声明，继续编译；没有则在本作用域声明一个变量b，初始化它的值为undefined;
1. 执行阶段，执行```b = 2```操作；
1. 对b作LHS查询，然后把2赋值给b；
1. 在全局作用域RHS查询foo，知道是一个函数，就进入函数并执行，进入子作用域；
1. 为形参a赋值，对a做LHS查询，然后把2赋值给a；
1. 对console作RHS查询，知道是一个内置对象，然后查找一下有没有log，知道log是一个函数，就执行
1. 对a做RHS，得到2；
1. 对b做RHS，在函数作用域没找到，然后去上一级作用域（全局作用域），找到了b，取到值2；
1. 执行log

---

```javascript
function foo (a) {

	console.log(a + b)
}

b = a;

foo(2)
```

1. 对b作LHS查询，在全局作用域没有，在非严禁模式下，自动声明变量b；
1. 对a作RHS查询，在全局作用域没找到，报错ReferenceError

说明过程

### 反思 & 总结

之前理解作用域实在太粗浅表面了，其实要了解它的工作流程，还需要了解js引擎的工作原理。

作用域是一套规则，用于确定在何处以及如何查找变量。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。

LHS和RHS查询都会在当前执行作用域中开始，如果没有找到所需的变量，就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到RHS都将停止，而如果是LHS，则在全局作用域里新建一个变量，作为全局对象的属性。

不成功的RHS引用会导致抛出ReferenceError异常；
不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下）;
不成功的LHS引用会导致抛出ReferenceError异常（严格模式下）。

ReferenceError 同作用域判别失败相关，而TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

### 参考资料
《You Don't Know Js》（主要参考）